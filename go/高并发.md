## 单元测试
	"github.com/smartystreets/goconvey/convey"
	"github.com/stretchr/testify/assert"

## 单例模式
sync.One

## 高并发
+ 协程池  make(chan struct{}, maxConcurrency) // 控制并发数
+ 缓冲channel  make(chan struct{}, bufferSize) // 控制缓冲区大小
+ waitgroup  sync.WaitGroup同步任务
+ context  context.WithCancel() 超时与取消context.WithTimeout()

## tps与qps
+ tps: 每秒处理的事务数量
+ qps: 每秒处理的查询次数

理论tps
TPS = (区块大小 / 平均交易大小) / 区块时间
若区块大小为 1 MB，每笔交易平均占 250 Bytes，则每个区块最多容纳 ‌4096 笔交易‌。
若区块时间为 10 秒，理论 TPS = 4096 / 10 = ‌409.6 TPS


## 高并发处理思路
+ 业务解耦+异步
  比如订单系统，和短信通知，订单成功后，将短信msg放到另外一个mq中执行


+ 熔断机制（如 Hystrix），降级非核心功能，---todo


## bitmap
```go
boolean isUsed(byte[] bitmap, int offset) {  
    int byteIndex = offset / 8;  
    int bitIndex = 7 - (offset % 8);  // 高位在前  
    return (bitmap[byteIndex] & (1 << bitIndex)) != 0;  
}  
```

## 服务优雅退出  
+ 信号捕捉
sigChan := make(chan os.Signal, 1)
signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
// 等待终止信号
<-sigChan

+ context.withcancel()

## redis Pipeline 
将多个命令打包发送并返回结果，减少网络请求次数，提高性能