# **Golang Map 底层实现原理**

Go 语言中的 `map` 是一种高效的 **哈希表（Hash Table）**  实现，用于存储键值对（Key-Value Pairs）。它的设计目标是 **快速查找、插入和删除**，平均时间复杂度为 **O(1)** （最坏情况下可能退化到 O(n)）。

* * *

## **1. Go Map 的核心结构**

Go 的 `map` 底层主要由以下部分组成：

-   **`hmap`（Header of Map）** ：存储 `map` 的元信息（如元素数量、桶数量、哈希种子等）。
-   **`bmap`（Bucket Map）** ：存储键值对的桶（Bucket），每个桶最多存储 8 个键值对。
-   **`mapextra`**（可选）：存储溢出桶（Overflow Bucket）信息，用于处理哈希冲突。

### **(1) `hmap` 结构（简化版）**

```go
type hmap struct {
    count     int    // 当前元素个数
    B         uint8  // 桶数量的对数（桶数 = 2^B）
    buckets   unsafe.Pointer // 指向桶数组的指针
    oldbuckets unsafe.Pointer // 扩容时用于暂存旧桶
    extra     *mapextra // 溢出桶信息
    // ... 其他字段（哈希种子、扩容标记等）
}
```

### **(2) `bmap`（桶结构）**

每个桶（`bmap`）存储 **8 个键值对**，并包含：

-   **`tophash` 数组**：存储每个键的哈希值的高 8 位，用于快速比较。
-   **键值对数组**：实际存储键和值（`key1, value1, key2, value2, ...`）。
-   **溢出指针**：如果桶满了，会链式链接到溢出桶（Overflow Bucket）。


```go
type bmap struct {
    tophash [8]uint8 // 每个键的哈希高 8 位
    keys    [8]keytype
    values  [8]valuetype
    overflow *bmap // 溢出桶
}
```

* * *

## **2. Go Map 的工作原理**

### **(1) 查找（`map[key]`）**

1.  **计算哈希值**：对 `key` 计算哈希（使用 `runtime.fastrand` 生成的随机种子）。

1.  **定位桶**：取哈希值的低 `B` 位（`hash & (2^B - 1)`）决定桶的位置。

1.  **遍历桶**：

    -   检查 `tophash` 是否匹配。
    -   如果匹配，再比较 `key` 是否相等。
    -   如果桶满，继续查溢出桶。

### **(2) 插入/更新（`map[key] = value`）**

1.  类似查找过程，找到对应的桶。
1.  如果有空位，直接写入；否则创建溢出桶。
1.  如果负载因子（元素数 / 桶数）超过 **6.5**，触发扩容。

### **(3) 删除（`delete(map, key)`）**

1.  找到对应的键值对。
1.  标记 `tophash` 为 `emptyOne`（表示已删除）。
1.  不会立即收缩内存，但后续扩容可能回收空间。

* * *

## **3. 哈希冲突处理**

Go 采用 **链地址法（Separate Chaining）**  处理冲突：

-   每个桶最多存 8 个键值对。
-   如果桶满了，会创建 **溢出桶（Overflow Bucket）**  并链式链接。
-   查找时，先查主桶，再查溢出桶。

* * *

## **4. 扩容机制**

当 `map` 的 **负载因子 > 6.5** 或 **溢出桶过多** 时，会触发扩容：

### **(1) 增量扩容（渐进式扩容）**

-   分配新桶数组（大小为原来的 2 倍）。
-   逐步将旧桶数据迁移到新桶（每次写入时迁移一部分）。
-   查询时，同时检查新旧桶。

### **(2) 等量扩容（Same-Size Expansion）**

-   如果溢出桶太多（但元素不多），会重新整理桶，减少溢出链。

* * *

## **5. Go Map 的特性**

| 特性        | 说明                                   |
| --------- | ------------------------------------ |
| **无序遍历**  | `range map` 顺序随机（防止依赖哈希顺序的攻击）        |
| **非线程安全** | 并发读写会 panic（需用 `sync.Map` 或 `mutex`） |
| **动态扩容**  | 自动扩容，但可能短暂影响性能                       |
| **内存占用**  | 相比 `slice` 更高（存储哈希和溢出链）              |

* * *

## **6. 代码示例**

```go
package main

import "fmt"

func main() {
    m := make(map[string]int) // 初始化 map
    m["Alice"] = 25           // 插入
    m["Bob"] = 30

    age, ok := m["Alice"]     // 查找（ok 判断是否存在）
    fmt.Println(age, ok)      // 输出: 25 true

    delete(m, "Bob")          // 删除
    fmt.Println(m)            // 输出: map[Alice:25]
}
```

* * *

## **7. 总结**

-   **底层结构**：`hmap` + `bmap`（桶 + 溢出桶）。
-   **哈希冲突**：链地址法（溢出桶）。
-   **扩容机制**：负载因子 > 6.5 或溢出桶过多时触发。
-   **时间复杂度**：平均 O(1)，最坏 O(n)（如所有 key 哈希冲突）。
-   **适用场景**：高频查找、插入、删除，但不适合高并发（需加锁）。