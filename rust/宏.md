## 宏

+ 过程宏 vec! 
```rust
macro_rules! hashmap {
    ($($key:expr => $value:expr),*) => {{
        let mut map = std::collections::HashMap::new();
        $(map.insert($key, $value);)*
        map
    }};
}
// 使用：let map = hashmap!{"a" => 1, "b" => 2};
```

+ 派生宏
  - 派生宏 #[derive(Serialize)]
  - 属性宏 #[my_attr]
  - 函数宏 foo!(...)

‌核心依赖库‌：
+ ‌syn‌：解析输入的 TokenStream 为 AST 结构‌34。
+ ‌quote‌：将 AST 转换回 TokenStream，生成新代码‌37。
+ ‌proc-macro2‌：提供跨版本的 TokenStream 兼容支持‌37。

派生
```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyDerive)]
pub fn my_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);  // 解析输入为 AST‌:ml-citation{ref="3,4" data="citationList"}
    let name = &ast.ident;
    let gen = quote! {  // 生成新代码
        impl #name {
            pub fn hello() {
                println!("Hello from MyDerive!");
            }
        }
    };
    gen.into()  // 输出为 TokenStream‌:ml-citation{ref="3,7" data="citationList"}
}
```
属性
```rust
use proc_macro::TokenStream;  
use quote::quote;  
use syn::{parse_macro_input, ItemStruct};  

#[proc_macro_attribute]  
pub fn make_fields_public(_attr: TokenStream, input: TokenStream) -> TokenStream {  
    let mut ast = parse_macro_input!(input as ItemStruct);  
    // 遍历结构体字段，设为 public  
    for field in ast.fields.iter_mut() {  
        field.vis = syn::Visibility::Public(syn::VisPublic { pub_token: syn::token::Pub::default() });  
    }  
    quote! { #ast }.into()  
}  
```
函数
```rust
use proc_macro::TokenStream;
use quote::quote;

#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // 解析输入 TokenStream 并生成代码
    let gen = quote! {
        println!("Generated by macro: {:?}", #input);
    };
    gen.into()  // 返回新 TokenStream‌:ml-citation{ref="5,8" data="citationList"}
}
```

## 异步

+ async/await
+ tokio
+ futures